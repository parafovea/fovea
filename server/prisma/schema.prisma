// Prisma Schema for Fovea Video Annotation Tool
// This schema defines the database structure for personas, videos, ontologies, annotations, and summaries

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [pgvector(map: "vector")]
}

/// User represents an authenticated user of the system
model User {
  id           String    @id @default(uuid())
  username     String    @unique
  email        String?   @unique
  passwordHash String?   // Nullable for single-user mode default user
  displayName  String
  isAdmin      Boolean   @default(false)

  // Relationships
  personas     Persona[]
  apiKeys      ApiKey[]
  sessions     Session[]
  worldState   WorldState?

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@map("users")
}

/// Session stores user authentication sessions
model Session {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([token])
  @@index([userId, expiresAt])
  @@map("sessions")
}

/// ApiKey stores encrypted API keys for external services (user-level or admin-level)
model ApiKey {
  id           String    @id @default(uuid())
  userId       String?   // NULL for admin-level keys
  user         User?     @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Provider: anthropic, openai, google, cohere, mistral, aws, azure, roboflow, cloudsight, edenai
  provider     String
  /// User-friendly label for this key
  keyName      String
  /// AES-256-GCM encrypted API key
  encryptedKey String
  /// Last 4 characters for display (e.g., "...Xy9Z")
  keyMask      String
  /// Whether this key is active
  isActive     Boolean   @default(true)
  /// Last time this key was used
  lastUsed     DateTime?
  /// Number of times this key has been used
  usageCount   Int       @default(0)

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([userId, provider])
  @@index([provider])
  @@map("api_keys")
}

/// Persona represents an analyst or user with their own ontology and interpretations
model Persona {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  name            String
  role            String
  informationNeed String
  details         String?
  isSystemGenerated Boolean @default(false)
  hidden          Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  ontology        Ontology?
  videoSummaries  VideoSummary[]
  annotations     Annotation[]

  @@map("personas")
}

/// Ontology defines the types (entities, events, roles, relations) for a specific persona
model Ontology {
  id             String   @id @default(uuid())
  personaId      String   @unique
  persona        Persona  @relation(fields: [personaId], references: [id], onDelete: Cascade)

  /// JSON structure: EntityType[]
  entityTypes    Json     @default("[]")
  /// JSON structure: EventType[]
  eventTypes     Json     @default("[]")
  /// JSON structure: RoleType[]
  roleTypes      Json     @default("[]")
  /// JSON structure: RelationType[]
  relationTypes  Json     @default("[]")

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("ontologies")
}

/// WorldState stores the actual instances of entities, events, locations, times, and collections
/// This is shared across all personas (personas assign types to these instances)
/// Each user has their own world state
model WorldState {
  id                String   @id @default(uuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// JSON structure: Entity[]
  entities          Json     @default("[]")
  /// JSON structure: Event[]
  events            Json     @default("[]")
  /// JSON structure: Time[]
  times             Json     @default("[]")
  /// JSON structure: EntityCollection[]
  entityCollections Json     @default("[]")
  /// JSON structure: EventCollection[]
  eventCollections  Json     @default("[]")
  /// JSON structure: TimeCollection[]
  timeCollections   Json     @default("[]")
  /// JSON structure: OntologyRelation[]
  relations         Json     @default("[]")

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@map("world_state")
}

/// Video represents a video file with its metadata
model Video {
  id          String   @id @default(uuid())
  filename    String   @unique
  path        String
  duration    Float?
  frameRate   Float?
  resolution  String?
  /// Additional metadata stored as JSON
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  /// Local thumbnail path (relative to DATA_DIR/thumbnails)
  localThumbnailPath String?
  /// Last successful metadata sync timestamp
  lastMetadataSync   DateTime?
  /// Platform this video originated from (e.g., 'twitter', 'youtube')
  sourcePlatform     String?
  /// Platform-specific video ID
  platformVideoId    String?
  /// Metadata sync status: 'synced', 'failed', 'never'
  metadataSyncStatus String?

  summaries   VideoSummary[]
  annotations Annotation[]

  @@map("videos")
}

/// VideoSummary stores AI-generated or manual summaries of videos for specific personas
model VideoSummary {
  id              String   @id @default(uuid())
  videoId         String
  video           Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)
  personaId       String
  persona         Persona  @relation(fields: [personaId], references: [id], onDelete: Cascade)

  /// JSON structure: GlossItem[] - array of {type, content, refType?, refPersonaId?, refClaimId?}
  summary         Json     @default("[]")
  visualAnalysis  String?
  audioTranscript String?
  /// JSON structure for key frame data
  keyFrames       Json?
  confidence      Float?

  /// Audio metadata fields
  /// JSON structure: {segments: [{start, end, text, speaker, confidence, sentiment}], speakers, language}
  transcriptJson  Json?
  /// ISO language code detected from audio (e.g., "en", "es")
  audioLanguage   String?
  /// Number of distinct speakers detected
  speakerCount    Int?

  /// Model metadata
  /// Name of audio transcription model used (e.g., "whisper-v3-turbo", "assemblyai-universal")
  audioModelUsed  String?
  /// Name of visual analysis model used (e.g., "gemini-2-5-flash", "gpt-4o")
  visualModelUsed String?
  /// Audio-visual fusion strategy used (e.g., "sequential", "timestamp_aligned", "native_multimodal", "hybrid")
  fusionStrategy  String?

  /// Processing time metadata (in seconds)
  processingTimeAudio  Float?
  processingTimeVisual Float?
  processingTimeFusion Float?

  /// Processing completion timestamps
  processedAtAudio  DateTime?
  processedAtVisual DateTime?
  processedAtFusion DateTime?

  /// Vector embedding for semantic search (1536 dimensions for OpenAI embeddings)
  embedding       Unsupported("vector(1536)")?

  /// Claims extraction metadata
  /// Denormalized claims structure for fast access (JSON)
  /// Structure: { version: string, claims: Claim[], metadata: {...} }
  claimsJson      Json?
  /// Version of claim extraction algorithm used
  claimsVersion   String?
  /// Timestamp when claims were last extracted
  claimsExtractedAt DateTime?

  /// Relation to Claim model
  claims          Claim[]

  /// User who created this summary (or service ID for automated summaries)
  createdBy       String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([videoId, personaId])
  @@map("video_summaries")
}

/// Annotation represents a temporal-spatial annotation on a video
model Annotation {
  id          String   @id @default(uuid())
  videoId     String
  video       Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)
  personaId   String
  persona     Persona  @relation(fields: [personaId], references: [id], onDelete: Cascade)

  type        String
  label       String
  /// JSON structure for frame-level data (bounding boxes, timestamps, etc.)
  frames      Json
  confidence  Float?
  /// Source of annotation: manual, ai-assisted, automatic
  source      String   @default("manual")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("annotations")
}

/// ImportHistory tracks data imports from JSON Lines files
model ImportHistory {
  id            String   @id @default(uuid())
  filename      String
  importedBy    String?
  importOptions Json
  result        Json
  success       Boolean
  itemsImported Int
  itemsSkipped  Int
  createdAt     DateTime @default(now())

  @@map("import_history")
}

/// Claim represents an atomic factual statement from a summary
/// Supports hierarchical decomposition and claim sourcing
model Claim {
  id              String   @id @default(uuid())

  // Association with summary
  summaryId       String
  summaryType     String   // "video" or "collection"

  // Relation to VideoSummary (currently only video summaries supported)
  videoSummary    VideoSummary  @relation(fields: [summaryId], references: [id], onDelete: Cascade)

  // Claim content
  text            String   @db.Text
  /// JSON structure: GlossItem[] with #/@/^/$ references (types/objects/annotations/claims)
  gloss           Json     @default("[]")

  // Hierarchical structure (parent/child decomposition)
  parentClaimId   String?
  parentClaim     Claim?   @relation("ClaimHierarchy", fields: [parentClaimId], references: [id], onDelete: Cascade)
  subclaims       Claim[]  @relation("ClaimHierarchy")

  // Text span mapping - support discontiguous spans
  /// JSON structure: Array of {sentenceIndex?: number, charStart: number, charEnd: number}
  textSpans       Json?

  // Claim source/claimer (who makes this claim)
  /// null = standalone claim for reference only (not asserted by anyone)
  /// "author" = video creator explicitly asserts this claim
  /// other = specified entity/type asserts this claim
  claimerType     String?  // null, "entity", "entity_type", "author", "mixed"
  /// JSON structure: GlossItem[] - mixed text and #/@/^/$ references for claimer
  claimerGloss    Json?

  // Relation between claimer and claim (how claimer relates to claim)
  /// JSON structure: GlossItem[] - mixed text and references (e.g., "says", "#claims", "denied that")
  claimRelation   Json?

  // Context of the claiming event itself (when/where claim was made)
  /// Reference to world state event object
  claimEventId    String?
  /// Reference to world state time object
  claimTimeId     String?
  /// Reference to world state location object
  claimLocationId String?

  // Metadata
  confidence      Float?   // Model confidence in claim extraction (0.0-1.0)
  modelUsed       String?  // Model that generated this claim (e.g., "llama-4-scout")
  extractionStrategy String? // "sentence-based", "semantic-units", "hierarchical", "manual"

  // Audit fields
  createdBy       String?  // User ID who created/approved this claim
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations to other claims (this claim as source or target)
  sourceClaimRelations ClaimRelation[] @relation("SourceClaim")
  targetClaimRelations ClaimRelation[] @relation("TargetClaim")

  @@index([summaryId, summaryType])
  @@index([parentClaimId])
  @@map("claims")
}

/// ClaimRelation represents a typed relation between claims or claim spans
/// Supports any relation type from the ontology (conflicts, supports, elaborates, etc.)
/// Can relate entire claims or specific (discontiguous) spans within claims
model ClaimRelation {
  id              String   @id @default(uuid())

  sourceClaimId   String
  sourceClaim     Claim    @relation("SourceClaim", fields: [sourceClaimId], references: [id], onDelete: Cascade)

  targetClaimId   String
  targetClaim     Claim    @relation("TargetClaim", fields: [targetClaimId], references: [id], onDelete: Cascade)

  /// Reference to ontology relation type (e.g., "conflicts", "supports", "denies")
  relationTypeId  String

  // Optional span specification (if null, relation applies to entire claim)
  /// JSON structure: Array of {charStart: number, charEnd: number}
  /// Specifies discontiguous spans within source claim
  sourceSpans     Json?
  /// JSON structure: Array of {charStart: number, charEnd: number}
  /// Specifies discontiguous spans within target claim
  targetSpans     Json?

  // Optional metadata
  confidence      Float?
  notes           String?  @db.Text

  createdBy       String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([sourceClaimId])
  @@index([targetClaimId])
  @@index([relationTypeId])
  @@map("claim_relations")
}
